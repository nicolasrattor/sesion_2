<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Capacitaci√≥n en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="date" content="2020-12-07" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: center, middle

.linea-superior[]
.linea-inferior[]

&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitaci√≥n en R

## Procesamiento de bases de datos (1)

### Diciembre 2020





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Contenidos de hoy

El objetivo de esta sesi√≥n es aprender a manipular data frames.

Para cumplir con el objetivo, revisaremos los siguientes temas:

--

- Importaci√≥n de datos desde distintos formatos a R.

--

- Introducci√≥n a **dplyr**.

--

- Manipulaci√≥n b√°sica de columnas (`select()`, `rename()`).

--

- Manipulaci√≥n b√°sica de filas (`arrange()`, `filter()`).

--

- Herramientas b√°sicas de edici√≥n de datos (`if_else()`, `mutate()`).

--


Antes... revisaremos el **protocolo IPO** para organizar nuestro trabajo.

---

background-image: url("imagenes/IPO.PNG")
background-size: cover
class: center, bottom, inverse

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Protocolo IPO

El protocolo [IPO](https://juancarloscastillo.github.io/ipo/index_es.html) es una plantilla de carpetas de proyecto basada en el protocolo [TIER](https://www.projecttier.org/).

--

Se basa en generar un conjunto de archivos auto-contenidos organizado en una estructura de proyecto que cualquier persona pueda compartir y ejecutar. 

--

.medium-par[En vez de compartir nuestro c√≥digo, compartimos una gran carpeta con el c√≥digo, los archivos de entrada (INPUT) y los archivos de salida (OUTPUT). De esta forma, otro investigador podr√° "reproducir" nuestro procesamiento o an√°lisis.]

--

![](imagenes/Estructura IPO.PNG)

--

.medium-par[Cuando utilizemos Rmarkdown esto ser√° fundamental...]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Directorios de trabajo

Por ahora nos deja planteado el tema de la fijaci√≥n de **directorios relativos**.

--

El directorio o carpeta de trabajo es el lugar en nuestra computadora donde R buscar√° archivos para importarlos y al que ser√°n exportados.

Para identificar cu√°l es la ruta del directorio que est√° usando R se debe utilizar la funci√≥n `getwd()`.


```r
getwd()
```

```
## [1] "C:/Users/nicol/OneDrive - Instituto Nacional de Estadisticas/GitHub/Capacitaciones R al DET/sesion_2"
```

--

Es posible cambiar el directorio de trabajo usando la funci√≥n `setwd()`.


```r
setwd("C:/Users/nicol")
```



--

Cuando R esta cerrado, y uno abre un projecto o *script*, se fijar√° como directorio de trabajo la carpeta en la que se encuentra este c√≥digo.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Directorios de trabajo

Recomendaci√≥n: en los c√≥digos nunca alterar el directorio de trabajo. Dejar que el directorio se fije seg√∫n la carpeta en la que tenemos nuestro *script*.

--

Esto permite que el c√≥digo corra sin problemas en cualquier computador. 

--

Cuando queremos importar una base de datos no establecemos el **directorio absoluto**, el cu√°l en general contiene el nombre personal de la computadora (en nuestro caso `C:/Users/nicol...`).

--

Simplemente le decimos *"busca el archivo X en la carpeta `input` o `data` del proyecto que tenemos abierto"*. Es un **directorio relativo**:


```r
library(readr)
esi &lt;- read_csv2("data/esi-2019---personas.csv")
```

--

En mi computadora, que tiene el directorio `C:/Users/nicol...`, no abrir√≠a un archivo que est√° con la ruta de Juanito: `C:/Users/Juanito/Desktop/data/esi-2019---personas.csv`.

![](imagenes/error not exist directory.PNG)


---

background-image: url("imagenes/import.jpg")
background-size: cover
class: center, bottom, inverse

# Importaci√≥n de datos

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

**R** tiene distintos paquetes para importar datos, diferenciando la extensi√≥n
de los archivos.

--

Estos archivos pueden ser asignados a un objeto.

--

En esta sesi√≥n veremos como importar:

    - Archivos de STATA (.dta) y de SPSS (.sav).
    
    - Archivos de texto plano delimitados (.csv).
    
    - Archivos de excel (.xlsx, .xls).
--
Para importar archivos guardados desde STATA o SPSS, existe el paquete `haven`.


.center[&lt;img src="imagenes/logo_haven.png" width="200" /&gt;]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

El paquete **`haven`** forma parte del universo de **`tidyverse`**, pero a 
diferencia de otros paquetes de ese universo, es necesario cargar la librer√≠a
para poder usar las funciones asociadas.

--

Las funciones inclu√≠das consideran un lenguaje bastante expl√≠cito:

- STATA: `read_dta()` permite importar archivos con extensi√≥n ".dta".

- SPSS: `read_sav()` permite importar archivos con extensi√≥n ".sav".

--


```r
library(haven)
# El archivo se puede cargar desde una carpeta seg√∫n ruta absoluta
esi &lt;- read_dta(file = "C:/Users/usuario/Desktop/esi-2019---personas.dta")
# El archivo se puede cargar desde una carpeta seg√∫n ruta relativa
esi &lt;- read_dta(file = "data/esi-2019---personas.dta")
# ...o desde un sitio web
esi &lt;- read_sav(file = "http://www.ine.cl/docs/default-source/encuesta-suplementaria-de-ingresos/bbdd/spss_esi/2019/esi-2019---personas.sav")
```

--

El argumento "file" indica la ruta y el nombre del archivo a importar a **R**. La direcci√≥n del archivo debe utilizar **forward-slash** ("/") en vez de **backslash** ("\").

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

- Importaci√≥n de archivos de texto plano delimitados

--

Si el archivo que queremos importar corresponde a un archivo de texto plano 
delimitado, el universo de `tidyverse` cuenta con el paquete **`readr`**.

--

Entre las funciones de `readr` se encuentran:

  - **`read_csv()`**: se utiliza para importar archivos delimitados por coma.
    
  - **`read_csv2()`**: se utiliza para importar archivos delimitados por punto 
  y coma. Este tipo de delimitaci√≥n se utiliza cuando la coma se utiliza para 
  separar n√∫meros decimales.
    
  - **`read_delim()`**: se utiliza para importar archivos planos con cualquier 
    delimitador. Al usar esta funci√≥n es necesario definir el argumento 
    `delim`, para identificar el tipo de delimitador.

--

Todas estas funciones tienen una sintaxis similar.


```r
library(readr)
## descargar base de https://www.ine.cl/estadisticas/sociales/ingresos-y-gastos/encuesta-suplementaria-de-ingresos
esi &lt;- read_csv2(file = "data/esi-2019---personas.csv")
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Estas funciones emplean la primera fila de los datos para los nombres de las 
columnas.

--

En caso de que los datos no incluyan los nombres, se puede agregar el argumento 
`col_names` = FALSE, y la funci√≥n entender√° que se deber√°n crear nombres 
ficticios, etiquetados secuencialmente desde X1 a Xn.

--

- Importaci√≥n de archivos de Excel

--

El paquete `readxl` nos permite importar archivos de Excel.

Una de sus funciones es `read_excel()`, y al igual que las funciones vistas 
previamente, se debe definir el argumento donde se encuentra el archivo, que 
en esta funci√≥n se llama `path`.

A diferencias de los otros tipos de archivos que hemos visto, los libros de 
excel pueden contar con m√°s de una hoja; el argumento `sheet` se utiliza para 
definir hoja que se importar√°.


```r
library(readxl)
esi &lt;- read_excel(path = "data/esi-2019---personas.xlsx",
                  sheet = "Hoja1")
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

- Importaci√≥n de archivos de R

--

Los archivos de R poseen la extensi√≥n ".RData".

--

La funci√≥n `load()` se utiliza para cargar el archivo.

--

No es necesario cargar librer√≠as para poder utilizar la funci√≥n.

--

No se debe asignar el valor al objeto a cargar.

--

**Importante**: estos archivos pueden incluir m√°s de un objeto.



```r
#esi &lt;- read_csv2(file = "data/esi-2019---personas.csv")
#esi2 &lt;- read_csv2(file = "data/esi-2019---hogares-sin-becas.csv")
#esi3 &lt;- read_csv2(file = "data/esi-2019---hogares-con-becas.csv")
#save(esi,esi2,esi3, file = "data/esi-2019.RData")
load(file = "data/esi-2019.RData")
```

![](imagenes/esiRData.PNG)

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Un peque√±o ejercicio...

- Cargue el archivo "ene-2019-11.csv" (se utiliza "," para separar los valores)

- Asigne al objeto "ene" el archivo cargado.

- Identifique la clase del objeto "ene".

- Identifique las dimensiones del objeto "ene".

--


```r
library(readr)
ene &lt;- read.csv(file = "data/ene-2019-11.csv")
class(ene)
```

```
## [1] "data.frame"
```

```r
dim(ene)
```

```
## [1] 96240   144
```

---

background-image: url("imagenes/transformer.gif")
background-size: cover
class: center, bottom, inverse

# Transformaci√≥n de datos

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## El paquete `dplyr`

.pull-left[

Para la manipulaci√≥n de los data frames existe un paquete llamado **`dplyr`**.

Este paquete fue desarrollado por Hardley Wickman de RStudio.

Es una versi√≥n optimizada de un paquete anterior llamado `plyr`.
 
El paquete `dplyr` proporciona una "gram√°tica" (particularmente verbos) para la 
manipulaci√≥n y operaciones con data frames.
 
Los paquetes `dplyr`, `readr`, `readxl` y `haven` forman parte del universo de 
[`tidyverse`](https://www.tidyverse.org).

]

.pull-right[
.center[
![](https://d33wubrfki0l68.cloudfront.net/071952491ec4a6a532a3f70ecfa2507af4d341f9/c167c/images/hex-dplyr.png)
]
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Durante esta sesi√≥n veremos algunas funciones del paquete **`dplyr`**, que se 
utilizan para la manipulaci√≥n de data frames.

--

**Manipulaci√≥n b√°sica de columnas**

--

- **`select()`**: selecciona y devuelve un conjunto de columnas.

--

- **`rename()`**: renombra variables en un data frame.

--

**Manipulaci√≥n b√°sica de filas**

--

- **`arrange()`**: reordena filas de un data frame.

--

- **`filter()`**: selecciona y devuelve un conjunto de filas seg√∫n una o varias 
condiciones l√≥gicas.

--

**Herramientas b√°sicas de edici√≥n de datos**

--

- **`if_else()`**: evaluaci√≥n de condiciones, y asignaci√≥n de valores.

--

- **`mutate()`**: a√±ade nuevas variables o transforma variables existentes.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Todas estas funciones tienen en com√∫n una serie de argumentos:

--

- El primer argumento es el data frame a manipular.

--

- Los otros argumentos describen qu√© hacer con el data frame especificado en el 
primer argumento.

--

- El valor de retorno de la funci√≥n es un nuevo data frame.

--

Estas funciones ser√°n algunas de nuestras mejores compa√±eras y siempre nos 
acompa√±ar√°n en nuestro camino de programaci√≥n.

--

Como veremos en esta sesi√≥n, una de las principales ventajas de estas funciones 
es que podemos referirnos a las columnas en el data frame directamente sin 
utilizar el operador "**$**", es decir, solo con el nombre de la variable.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`select()`**

--

Esta funci√≥n es utilizada para seleccionar columnas dentro de un data frame.

--

El resultado de esta funci√≥n corresponde a un data frame que solo incluye las 
variables seleccionadas.

--

El orden de las variables corresponde al orden seleccionado.

--

.center[
&lt;img src="imagenes/select.png" width="300" /&gt;
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`select()`**

Existen m√∫ltiples formas de seleccionar las columnas utilizando esta funci√≥n.

--

- Selecci√≥n de las columnas a trav√©s del nombre de los campos.

--


```r
library(dplyr)
```

```
## Warning: package 'dplyr' was built under R version 3.6.3
```

```r
head(select(ene, ano_encuesta, mes_encuesta, cae_especifico, b1, b14_rev4cl_caenes),
     n = 3) # el argumento n corresponde a la funci√≥n "head"
```

```
##   ano_encuesta mes_encuesta cae_especifico b1 b14_rev4cl_caenes
## 1         2019           10             17 NA                NA
## 2         2019           10             17 NA                NA
## 3         2019           10              7  7                 2
```

--

- Selecci√≥n de las columnas a trav√©s de la posici√≥n que ocupan en el data frame.

--


```r
head(select(ene, 1, 2, 3, 4, 5),
     n = 3)
```

```
##     idrph ano_trimestre mes_central id_identificacion id_directorio
## 1  808409          2019          11            173296         21343
## 2  808410          2019          11            173296         21343
## 3 1100843          2019          11            235727         16373
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`select()`**

- Selecci√≥n de las columnas a trav√©s de rangos.
    - Estos rangos se pueden definir a trav√©s de los nombres de campos o de las 
    posiciones.

--


```r
head(select(ene, c(idrph:mes_central)), n = 3)
```

```
##     idrph ano_trimestre mes_central
## 1  808409          2019          11
## 2  808410          2019          11
## 3 1100843          2019          11
```

--

- Selecci√≥n negativa utilizando el signo "-" antes de la variable.
    - Consiste en seleccionar las variables que no queremos en la base final.

--


```r
head(select(ene, -c(4:length(ene))), n = 3)
```

```
##     idrph ano_trimestre mes_central
## 1  808409          2019          11
## 2  808410          2019          11
## 3 1100843          2019          11
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`select()`**

A continuaci√≥n un resumen de las principales funciones auxiliares que se pueden 
utilizar con `select()`:

- "**-**": se utiliza para identificar los campos a excluir de la selecci√≥n.

- "**:**": se utiliza para definir un rango.

- **contains()**: selecciona variables cuyo nombre contiene la cadena de 
texto definida.

- **ends_with()**: selecciona variables cuyo nombre termina con la cadena de 
texto definida,

- **start_with()**: selecciona variables cuyo nombre comienza con la cadena de 
texto definida,

- **matches()**: selecciona las variables cuyos nombres coinciden con una 
[*expresi√≥n regular*](https://rpubs.com/ydmarinb/429756).

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Dos peque√±os ejercicios...

--

- Seleccione las variables idrph, edad, sexo, cine.
  
--


```r
head(select(ene, idrph, edad, sexo, cine), n = 3)
```

```
##     idrph edad sexo cine
## 1  808409   79    1    5
## 2  808410   71    2    8
## 3 1100843   53    1    5
```

--

- Seleccione la variable idrph y las variables que terminen en "caenes"

--
  

```r
head(select(ene, idrph, ends_with("caenes")), n = 3)
```

```
##     idrph b13_rev4cl_caenes b14_rev4cl_caenes e18_rev4cl_caenes
## 1  808409                NA                NA                15
## 2  808410                NA                NA                16
## 3 1100843                 3                 2                NA
##   r_p_rev4cl_caenes
## 1                NA
## 2                NA
## 3                 3
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`rename()`**

--

Si necesitamos renombrar una variable (columna) de un data frame, existen 
m√∫ltiples formas y varias muy complejas.

--

La funci√≥n `rename()` permite editar el nombre de una variable de una manera 
sencilla, y sin afectar al resto de variables.

--

Esta funci√≥n permite renombrar m√°s de una variable a la vez.

--

Si queremos obtener el nombre de las variables de un data frame, se utiliza la 
funci√≥n `names()`

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`rename()`**

A continuaci√≥n se mostrar√°n dos formas de renombrar variables...

--


```r
ene_5 &lt;- select(ene, idrph, edad, sexo, cine)
names(ene_5)
```

```
## [1] "idrph" "edad"  "sexo"  "cine"
```

--

...a trav√©s del lenguaje base

--


```r
names(ene_5)[names(ene_5) == "sexo"] &lt;- "sex"
names(ene_5)
```

```
## [1] "idrph" "edad"  "sex"   "cine"
```

--

...a trav√©s de `rename()`

--


```r
names(rename(ene_5, identificador = idrph, niveleducacional = cine))
```

```
## [1] "identificador"    "edad"             "sex"              "niveleducacional"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Uso de **pipes** (**`%&gt;%`**)

Como hemos visto hasta ahora, estas funciones siguen la misma estructura:

    - Primer argumento: data frame sobre el que se aplica la funci√≥n.
    
    - Resto de argumentos: elementos del data frame sobre los cuales actua
    la funci√≥n.
    
--

Lo anterior nos puede hacer pensar: **¬øes posible encadenar estas funciones?**.

--

Si...
--
si se puede, utilizando el operador **`%&gt;%`** (llamado **pipe**).

---

background-image: url("imagenes/pipes.jpg")
background-size: cover
class: center, bottom, inverse

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Uso de **pipes** (**`%&gt;%`**)

El operador **%&gt;%** nos permite tomar el resultado de una funci√≥n y mandarlo 
directamente a la siguiente funci√≥n, concatenando acciones.

--

Se puede leer como "luego" o "a continuaci√≥n".

--

Este operador nos ayudar√° enormemente a mejor la legibilidad de un c√≥digo.

--

El atajo en Windows para escribir `pipes` es: ctrl + shift + m.

En Mac es: cmd + shift + m

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Uso de **pipes** (**`%&gt;%`**)

Para utilizar los pipes, es necesario seguir la siguiente estructura:


```r
df %&gt;% # data frame sobre el que se ejecutar√° la funci√≥n
  funcion() %&gt;% # esta funci√≥n se aplica sobre el data frame "df"
  funcion() # esta funci√≥n se aplica sobre el resultado de la funci√≥n anterior
```

--

Utilizando pipes, el resultado del ejercicio de renombrar es posible escribirlo 
de la siguiente manera:

--


```r
ene_6 &lt;- ene %&gt;%
  select(idrph, edad, sexo, cine) %&gt;%
  rename(identificador = idrph, niveleducacion = cine)
names(ene_6)
```

```
## [1] "identificador"  "edad"           "sexo"           "niveleducacion"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`filter()`**

--

Esta funci√≥n se utiliza para filtrar un data frame seg√∫n alguna condici√≥n a 
definir.

--

As√≠ como la funci√≥n `select()` es utilizada para seleccionar columnas de un 
data frame, la funci√≥n `filter()` es utilizada para seleccionar las filas de 
un data frame.

--

.center[
&lt;img src="imagenes/filter.png" width="400" /&gt;
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`filter()`**

Al aplicar esta funci√≥n, los resultados que quedar√°n en el dataframe resultante 
ser√°n solo aquellos en los que se cumpla la condici√≥n definida. Por ejemplo...

--

...el n√∫mero de filas del data frame "ene" es:

--


```r
dim(ene)
```

```
## [1] 96240   144
```

--

...mientras que el n√∫mero de filas del data frame "ene" que corresponde al mes 
de encuestaje de diciembre es:

--


```r
dim(ene %&gt;% filter(mes_encuesta == 12))
```

```
## [1] 34402   144
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`filter()`**

Las condiciones para filtrar un data frame pueden ser construidas mediante 
operadores relacionales.

--

A continuaci√≥n se presenta un listado de operadores relacionales:

--

- "**&lt;**": menor que
- "**&gt;**": mayor que
- "**==**": igual que
- "**&lt;=**": menor o igual que
- "**&gt;=**": mayor o igual que
- "**!=**": diferente que
- "**%in%**": pertenece al conjunto
- "**is.na**": es NA
- "**!is.na**": no es NA

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`filter()`**

¬øEs posible filtrar un data frame por m√°s de una condici√≥n al mismo tiempo?

--

**Si**, es posible utilizando **operadores l√≥gicos**.

--

Estos operadores se utilizan para analizar el valor de verdad de dos sentencias.

--

Algunos operadores l√≥gicos o booleanos son:

--

- "**&amp;**": conjunci√≥n y
- "**|**": conjunci√≥n o
- "**!**": operador no
- "**any**": al menos una sentencia es verdadera
- "**all**": todas las sentencias son verdaderas

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`filter()`**

Algunos ejemplos...

--

- Obtener el n√∫mero de filas de registros con edad mayor a 50 y cuyo 
grupo ocupacional corresponde a profesionales cient√≠ficos e intelectuales 
(b1 == 2).

--


```r
dim(ene %&gt;% filter(edad &gt; 50 &amp; b1 == 2))
```

```
## [1] 1225  144
```

--

- Obtener el n√∫mero de filas de registros que cumplan al menos una de las 
dos relaciones siguiente:
    
    - Mujeres (sexo == 2) de la regi√≥n 6.
    - Hombres (sexo == 1) de la regi√≥n 12.

--


```r
dim(ene %&gt;% filter(sexo == 2 &amp; region == 6 | sexo == 1 &amp; region == 12))
```

```
## [1] 4023  144
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`arrange()`**

--

Esta funci√≥n se utiliza para reordenar las filas de un data frame.

--

- El orden se puede realizar seg√∫n una o m√°s variables.

--

- El reordenamiento se realiza seg√∫n el orden de las columnas seleccionadas.

--

- Por defecto, el orden es ascendente.

--

- Para ordenar de manera descendente se debe utilizar la funci√≥n auxiliar 
`desc()`.


```r
library(guaguas)
```

```
## Warning: package 'guaguas' was built under R version 3.6.3
```

```r
head(guaguas %&gt;% arrange(desc(n)), n = 3)
```

```
## # A tibble: 3 x 5
##    anio sexo  nombre     n proporcion
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;int&gt;      &lt;dbl&gt;
## 1  1955 F     Mar√≠a  21448     0.0862
## 2  1956 F     Mar√≠a  21014     0.0834
## 3  1965 F     Mar√≠a  20382     0.0639
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Algunos ejercicios sobre lo visto hasta ahora en clases...

--

- Utilizando la base de guaguas, filtre seg√∫n su a√±o de nacimiento, su sexo de 
nacimiento, y luego ordene el resultado por la variable "n", de forma 
descendente.

- Utilice la funci√≥n "head", con el argumento "n == 5", e identifique cuantos 
nombres de los 5 m√°s repetidos comienzan con la letra "J".

--


```r
library(guaguas)
head(guaguas %&gt;%
       filter(sexo == "M", anio == 1990) %&gt;% # Hombres nacidos en 1990
       arrange(desc(n)), n = 5)
```

```
## # A tibble: 5 x 5
##    anio sexo  nombre        n proporcion
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;      &lt;dbl&gt;
## 1  1990 M     Juan       5839     0.0185
## 2  1990 M     Jos√©       5461     0.0173
## 3  1990 M     Luis       4634     0.0147
## 4  1990 M     Sebasti√°n  4632     0.0147
## 5  1990 M     Francisco  4468     0.0142
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

Esta funci√≥n tiene la finalidad de realizar transformaciones sobre los valores 
de un data frame.

--

Algunas de las transformaciones posibles son:

--

- Cambiar el formato de una variable.

Por ejemplo: modificar el formato de la variable "idrph" a character.

--


```r
class(ene$idrph)
```

```
## [1] "integer"
```

--


```r
ene &lt;- ene %&gt;% mutate(idrph = as.character(idrph))
```

--


```r
class(ene$idrph)
```

```
## [1] "character"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

- Modificar el valor de alguna variable.

--

Esta funci√≥n tambi√©n nos permite crear nuevas variables en un data frame.

--

Con esta funci√≥n se pueden combinar funciones b√°sicas para realizar operaciones 
sobre las variables.

--

Con `mutate()` podemos editar y/o crear m√°s de una variable. Es necesario 
separar las instrucciones entre variables con una coma.

--

Al trabajar sobre m√°s de una variable, la funci√≥n primero trabajar√° sobre 
la primera instrucci√≥n previa a la primera coma que separe las instrucciones, 
luego, avanzar√° sobre la siguiente.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

Ejemplo

--


```r
df &lt;- data.frame(x = c(1, 2),
                 y = c(5, 5))
print(df)
```

```
##   x y
## 1 1 5
## 2 2 5
```

--


```r
df &lt;- df %&gt;%
  mutate(y = 10,
         z = x*y)
print(df)
```

```
##   x  y  z
## 1 1 10 10
## 2 2 10 20
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

--

Como pudimos ver, las variables creadas son agregadas al final del data frame.

--

¬øEs posible definir la posici√≥n donde ser√°n agregadas?

--

Si, agregando el argumento ".before" o el argumento ".after".

--


```r
df &lt;- df %&gt;% mutate(w = "ejemplo", .before = x)
print(df)
```

```
##         w x  y  z
## 1 ejemplo 1 10 10
## 2 ejemplo 2 10 20
```

--

El paquete `dplyr` tambi√©n cuenta con la funci√≥n `relocate()` que nos permite 
ordenar algunas columnas dentro de un data frame.


```r
df %&gt;% relocate(c(w, z), .after = x)
```

```
##   x       w  z  y
## 1 1 ejemplo 10 10
## 2 2 ejemplo 20 10
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

Hasta ahora hemos visto como crear variables donde todas las filas cumplan las 
mismas condiciones, pero no siempre es as√≠. **¬øC√≥mo podemos trabajar cuando **
**la creaci√≥n de una variable depende del valor de otra?**

--

Por ejemplo:

--

    - Si la variable sexo es igual a 1, asigne tal valor, en cambio, si la 
    variable sexo es igual a 2, asigne otro valor.
    
    - Si la variable regi√≥n es igual a 1, 15, 2, la variable zona tendr√° el 
    valor "norte", en cambio si la variable es igual a 12, la variable zona 
    tendr√° el valor "sur".

--

Esto se puede realizar utilizando una funci√≥n llamada `if_else()`, cuyo 
objetivo es evaluar el valor de verdad de una sentencia, y luego entregar un 
resultado seg√∫n ese valor. Esta funci√≥n se puede utilizar junto a la funci√≥n 
`mutate()`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

La funci√≥n `if_else()` trabaja con los siguientes argumentos:

--

- **condition**: corresponde a la sentencia a evaluar.

--

- **true**: indica el valor a asignar si la sentencia es verdadera.

--

- **false**: indica el valor a asignar si la sentencia es falsa.

--

- **missing**: indica el valor a asignar si la sentencia es missing.


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

La funci√≥n **if_else()** act√∫a sobre cada fila, y otorga un valor distinto a 
cada celda dependiendo del valor de verdad por fila.

Ejemplo: recodificar la categor√≠a 10 de la variable b1 y asignarle el valor 0.

--


```r
ene &lt;- ene %&gt;% mutate(b1 = if_else(b1 == 10, 0, as.numeric(b1)))
table(ene$b1)
```

```
## 
##    0    1    2    3    4    5    6    7    8    9 
##  204 1099 4944 4994 1915 9215 2203 5294 3567 9421
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n **`mutate()`**

Entre las funciones b√°sicas de R, existe la funci√≥n `ifelse()`, la cual es 
menos estricta que `if_else()`, pero no tiene un tratamiento especial para los 
missings.

--

La funci√≥n `ifelse()` base solo trabaja con tres argumentos: "test", "yes" y 
"no".

--


```r
df2 &lt;- data.frame(x = c(1, 2, NA))
```

--


```r
df2 %&gt;% mutate(y = if_else(condition = (x == 1), true = "valido", 
                           false = "no valido", missing = "missing"))
```

```
##    x         y
## 1  1    valido
## 2  2 no valido
## 3 NA   missing
```

--


```r
df2 %&gt;% mutate(y = ifelse(test = (x == 1), yes = "valido", no = "no valido"))
```

```
##    x         y
## 1  1    valido
## 2  2 no valido
## 3 NA      &lt;NA&gt;
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Algunas funciones importantes que se pueden utilizar en conjunto con `mutate()` 
son:

--

- La funci√≥n `sum()`: utilizada para sumar los valores de una variable (suma 
de la columna).

- La funci√≥n `row_number()`: utilizada para asignarle un valor a cada fila 
igual a la posici√≥n que ocupan en el data frame.

- La funci√≥n `mean()`: utilizada para obtener la media de una columna.

- La funci√≥n `max()`: utilizada para obtener el valor m√°ximo de una variable.

- La funci√≥n `paste()`: utilizada para concatenar variables y/o strings.

- La funci√≥n `gsub()`: utilizada para reemplazar el valor de texto dentro de 
una variable.

- La funci√≥n `nchar()`: utilizada para contar el n√∫mero de caracter de una 
variable.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

A continuaci√≥n, un ejemplo...

--


```r
df4 &lt;- data.frame(x1 = c(1, 2, 3, 4, NA),
                  x2 = c(5, 13, -2, 1, 5),
                  x3 = c("y_1", "y_2", "y_3", "y_4", "y_5"))
df4 %&gt;% mutate(
  total = sum(x1),
  total_x1 = sum(x1, na.rm = T), # con na.rm no se consideran los missing
  media_x2 = mean(x2),
  n_fila = row_number(),
  x3_v2 = gsub("y", "v", x3))
```

```
##   x1 x2  x3 total total_x1 media_x2 n_fila x3_v2
## 1  1  5 y_1    NA       10      4.4      1   v_1
## 2  2 13 y_2    NA       10      4.4      2   v_2
## 3  3 -2 y_3    NA       10      4.4      3   v_3
## 4  4  1 y_4    NA       10      4.4      4   v_4
## 5 NA  5 y_5    NA       10      4.4      5   v_5
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Ejercicio final

Cree el data frame df3...


```r
df3 &lt;- data.frame(x = c(1, 2, NA, 5),
                  y = c(2, 4, 0, 15))
```

Luego...

- Edite la variable "x", de forma tal que el valor missing tome el valor 0.

- Genere la variable "division", que sea igual a la divisi√≥n entre "y" y "x".

- Filtre los casos donde division sea distinto de 2.

--


```r
df3 %&gt;%
  mutate(x = if_else(is.na(x), 0, x),
         division = y / x) %&gt;%
  filter(division != 2)
```

```
##   x  y division
## 1 5 15        3
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicios para la üè†

- Importar la base **ene-2019-11.csv**.

- Seleccionar las variables: idrph, edad, sexo, b1 y las variables cuyo nombre 
comienza con "cae_"

- Renombrar la variable *cae_especifico* por *cse_especifico*.

- Generar la variable *tipo_ocupado* en base a las siguientes reglas:

    - Asignarle el valor "presente" en caso que la variable cse_especifico
    se encuentre entre 1 y 4 (valores extremos incluidos).
    - Asignarle el valor "ausente" en caso que la variable cse_especifico 
    se encuentre entre 5 y 7 (extremos incluidos).
    - Asignarle el valor "no ocupado" en cualquier otro caso.
    
- Obtener el n√∫mero de ocupados ausentes codificados como "Directivos y 
Gerentes" (b1 == 1).

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Referencias

Nada de esto ser√≠a posible sin:

- [`R fot Data Science, de Hadley Wickham`](https://r4ds.had.co.nz/)

- [`Advanced R, de Hadley Wickham`](http://adv-r.had.co.nz/Introduction.html)

- [`Data wrangling, exploration, and analysis with R, de Jenny Bryan`](https://stat545.com/index.html)

- [`Introduction to R, de Data Carpentry`](https://datacarpentry.org/R-genomics/01-intro-to-R.html#functions)

- [`Xaringan: Presentation Ninja, de Yihui Xie`](https://github.com/yihui/xaringan). Para generar esta presentaci√≥n con la planilla ninja ‚öî

R for Data Science tiene una traducci√≥n al espa√±ol realizada por la comunidad hisp
ana de R:

- [`R para ciencia de datos, de Hadley Wickham`](https://es.r4ds.hadley.nz/)

---

class: center, middle

.linea-superior[]
.linea-inferior[]

&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitaci√≥n en R y herramientas de productividad

## Proyecto Estrat√©gico Servicios Compartidos para la Producci√≥n Estad√≠stica

## Procesamiento de bases de datos (1)

### Octubre 2020
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
